Reproducible Research: Peer Assessment 1
====



## Loading and preprocessing the data
```{r, message=FALSE}
library(dplyr)
library(magrittr)
library(lubridate)

unzip("activity.zip")
activity <- read.csv("activity.csv", stringsAsFactors = FALSE)
activity <- mutate(activity, date = ymd(date))
#The interval column encodes 5 minutes intervals. However, the representation
#changes from 55 to 100. which means 0H55min and 1H55min. For
#grouping/aggregation operations this wonÂ´t make much difference, but for
#plotting time series we will have a jump in the x axis, from 55 to 100 instead
#of very 5 units. Therefore, I will create a new column with the number of
#elapsed minutes from the start of the day.
activity <- mutate(activity, minutes <- seq(from = 0, by = 5, length.out = 288))
```



## What is mean total number of steps taken per day?


```{r}
steps_per_day <- activity %>% 
                 group_by(date) %>%
                 summarise(total_steps = sum(steps, na.rm = TRUE)) %>%
                 use_series(total_steps)


hist(x = steps_per_day)

mean(steps_per_day)

median(steps_per_day)
                 
```


## What is the average daily activity pattern?


```{r}
steps_per_time <- activity %>%
                  group_by(interval) %>%
                  summarise(average_steps = mean(steps, na.rm = TRUE))

plot(average_steps ~ interval, data = steps_per_time, type = "l")

steps_per_time[[which.max(steps_per_time$average_steps), "interval"]]

```

## Imputing missing values

There are several R packages that help with imputing missing values. However, lets keep it simple, as the instruction suggest.
First I thought taking the average of each day. However there are days without any value, which will have `NaN` as mean:



```{r}

average_steps_day <- activity %>%
                     group_by(date) %>%
                     summarise(average = mean(steps, na.rm = TRUE))

sum(is.nan(average_steps_day$average))
            

```

So, instead lets take the average for the 5 minute interval:

```{r}
# We have already calculated the average steps per interval in a previous
# question

activity <- activity %>%
            left_join(steps_per_time, by = "interval") 

#I wish I would find a way to do this with dplyr instead :(

for(i in seq_along(activity$steps)){
  activity$steps[i] <- ifelse(is.na(activity$steps[i]), 
                              activity$average_steps[i], 
                              activity$steps[i])
}
  

```



## Are there differences in activity patterns between weekdays and weekends?
